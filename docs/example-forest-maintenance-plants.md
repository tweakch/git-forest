# Example Plants Generated by Forest Maintenance Plan

This document shows examples of plants that the forest-maintenance plan might generate when analyzing the git-forest codebase.

## Example 1: Implementation Consistency Plant

```yaml
key: forest-maintenance:impl-spec-mismatch-exit-codes
status: planned
title: "Implementation mismatch: exit codes do not match CLI spec"
plan_id: forest-maintenance
category: impl-consistency
priority: high
description: |
  The CLI specification (CLI.md §11) defines specific exit codes for various error conditions.
  However, the current implementation may not use all defined exit codes consistently.
  
  Defined exit codes in spec:
  - 0: success
  - 2: invalid arguments / parse error
  - 10: forest not initialized
  - 11: plan not found
  - 12: plant not found / ambiguous selector
  - 13: planter not found
  - 20: schema validation failed
  - 23: lock timeout / busy
  - 30: git operation failed
  - 40: execution not permitted by policy
  
  Areas to verify:
  - Program.cs command handlers
  - Service implementations
  - Error handling paths
  
context:
  planner: impl-consistency
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - src/GitForest.Cli/Program.cs
    - src/GitForest.Core/Services/*.cs
  rationale: |
    Consistent exit codes are critical for automation and scripting.
    The CLI contract promises specific exit codes for error conditions.
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Example 2: Documentation Drift Plant

```yaml
key: forest-maintenance:doc-code-drift-plants-list
status: planned
title: "Documentation drift: docs/cli/plants.md is inconsistent with CLI.md"
plan_id: forest-maintenance
category: impl-consistency
priority: medium
description: |
  The legacy documentation in docs/cli/plants.md may not reflect the current
  CLI specification in CLI.md. The newer CLI.md (v0.2) has superseded the
  older docs/cli/ documentation.
  
  Discrepancies detected:
  - docs/cli/plants.md may use old command syntax
  - Filter options may differ
  - JSON output format may not be documented
  
  Recommended action:
  - Update docs/cli/plants.md to match CLI.md
  - Or deprecate docs/cli/ in favor of CLI.md
  - Or add note that CLI.md is the authoritative source
  
context:
  planner: impl-consistency
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - docs/cli/plants.md
    - CLI.md
  rationale: |
    Documentation drift confuses users and makes it harder to maintain
    the project. Single source of truth is important.
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Example 3: Code Health Plant

```yaml
key: forest-maintenance:complex-method-refactor-reconcile
status: planned
title: "Refactor complex method: ReconcilePlan in PlanService"
plan_id: forest-maintenance
category: code-health
priority: medium
description: |
  The ReconcilePlan method in src/GitForest.Core/Services/PlanService.cs
  (if implemented) may have high cyclomatic complexity.
  
  Reconciliation involves multiple steps:
  1. Load current plan state
  2. Run planners to get desired state
  3. Compute diff (creates, updates, archives)
  4. Apply changes to plants
  5. Update metadata
  6. Handle errors and rollback
  
  Refactoring suggestions:
  - Extract planner execution to separate method
  - Extract diff computation to separate method
  - Extract plant updates to separate method
  - Consider using a reconciliation pipeline pattern
  
context:
  planner: code-health
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - src/GitForest.Core/Services/PlanService.cs
  metrics:
    estimated_complexity: high
    estimated_lines: unknown
  rationale: |
    Complex methods are harder to test, understand, and maintain.
    Breaking down reconciliation logic improves code quality.
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Example 4: Forest Structure Validation Plant

```yaml
key: forest-maintenance:forest-structure-violation-lock-format
status: planned
title: "Fix forest structure: lock file format not specified"
plan_id: forest-maintenance
category: forest-validator
priority: medium
description: |
  The CLI specification mentions a lock file at .git-forest/lock but does
  not specify its format or contents.
  
  Missing specifications:
  - File format (text, binary, JSON?)
  - Contents (PID, timestamp, owner?)
  - Lock acquisition protocol
  - Lock timeout handling
  - Stale lock detection
  
  Recommended action:
  - Document the lock file format in CLI.md or separate spec
  - Implement consistent lock file handling
  - Add tests for lock timeout scenarios
  
context:
  planner: forest-validator
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - CLI.md
    - .git-forest/lock (when created)
  rationale: |
    Clear lock file specification prevents race conditions and
    makes concurrent access safe.
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Example 5: Plan Catalog Audit Plant

```yaml
key: forest-maintenance:plan-undocumented-new-plan
status: planned
title: "Document plan forest-maintenance in catalog"
plan_id: forest-maintenance
category: plan-catalog-auditor
priority: low
description: |
  The forest-maintenance plan was recently added but needs to be
  fully documented in the plan catalog README.
  
  Documentation status:
  ✅ Plan file exists: config/plans/meta-governance/forest-maintenance.yaml
  ✅ Listed in README: config/plans/README.md
  ✅ Contract documented: docs/forest-maintenance-contract.md
  ⚠️  Quick start guide: Created
  
  Recommendations:
  - Add usage examples to main README
  - Add to category documentation
  - Ensure consistent description across all docs
  
context:
  planner: plan-catalog-auditor
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - config/plans/README.md
    - README.md
  rationale: |
    Self-documenting behavior - the forest-maintenance plan should
    generate a plant about documenting itself!
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Example 6: Test Coverage Plant

```yaml
key: forest-maintenance:test-coverage-gap-plan-reconcile
status: planned
title: "Add tests for plan reconciliation: idempotency scenario"
plan_id: forest-maintenance
category: test-coverage
priority: high
description: |
  The plan reconciliation feature is a core part of git-forest's
  deterministic guarantees. It must be thoroughly tested.
  
  Missing test scenarios:
  1. Reconcile same plan twice → no changes second time (idempotency)
  2. Reconcile after code change → correct plants updated
  3. Reconcile with removed plants → plants archived correctly
  4. Reconcile with conflicts → proper error handling
  
  Test requirements:
  - Unit tests for reconciliation logic
  - Integration tests with real plan files
  - End-to-end tests via CLI
  
context:
  planner: test-coverage
  detected_at: 2024-12-14T01:00:00Z
  files_affected:
    - src/GitForest.Core/Services/PlanService.cs (to test)
    - tests/ (to be created)
  rationale: |
    Reconciliation is critical for deterministic behavior.
    Without tests, we can't guarantee it works correctly.
assigned_planters: []
branches: []
created_at: 2024-12-14T01:00:00Z
updated_at: 2024-12-14T01:00:00Z
```

## Plant Lifecycle

After plants are generated, they follow this lifecycle:

1. **planned** → Initial state after generation
2. **planted** → Planter assigned and working
3. **growing** → Changes proposed/in progress
4. **harvestable** → Ready for review/merge
5. **harvested** → Completed and closed

## Notes

- These are **example plants** showing the format and structure
- Actual plants generated will depend on the real state of the codebase
- The forest-maintenance plan generates plants **deterministically**
- Same codebase state always produces the same plant keys
- Running reconcile multiple times is safe (idempotent)
